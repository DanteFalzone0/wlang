import { Block, Expression, FunctionCall, FunctionDeclaration, Module, ParamDeclaration, Statement } from "./Ast";
import { Mut, NullablePointerType, Pointer, PointerType, PrimitiveType, primitiveTypes, ValueType } from "./Types";

export function compile(moduleAst: Module): string {
  let result =
`#include <stdint.h>
#include <stddef.h>
// C generated by v0.1.1 of the Wlang compiler
`;

  for (const functionDef of moduleAst.functions) {
    result += '\n' + compileFunction(functionDef);
  }

  return result;
}

function compileFunction(functionDec: FunctionDeclaration) {
  const returnType = convertToCType(functionDec.returnType);
  const parameters = functionDec.parameters.map(function(p: ParamDeclaration) {
    if (p === "varargs") {
      return "...";
    } else {
      const identifier = Object.keys(p)[0];
      const type = convertToCType(Object.values(p)[0] as ValueType);
      return `${type} ${identifier}`;
    }
  });
  let body = null;
  if (functionDec.body.type !== "Extern") {
    body = ` ${compileBlock(functionDec.body)}`;
  }
  if (parameters.includes("...") && parameters.slice(0, -1).includes("...")) {
    throw new Error(
      "Type error: a function that takes varargs can only take it as the last parameter."
    );
  }
  const signature =
    `${returnType} ${functionDec.identifier}(${parameters.join(", ")})`;
  return `${signature}${body ?? ';\n'}`;
}

function getIndentation(level?: number): string {
  if (level === undefined) {
    return "";
  } else {
    return "  ".repeat(level);
  }
}

function compileBlock(block: Block, indent?: number) {
  const indentation = getIndentation(indent);
  let result = indentation + "{\n";
  for (const statement of block.value) {
    result += compileStatement(statement, 1 + (indent ?? 0));
  }
  result += indentation + "}";
  return result;
}

function compileStatement(statement: Statement, indent?: number) {
  const indentation = getIndentation(indent);
  switch (statement.type) {
    case "Statement":
      return `${indentation}${compileExpression(statement.body)};\n`
    case "ResultStatement":
      return `${indentation}return ${compileExpression(statement.body)};\n`
    default:
      throw new Error("Internal error: Something is wrong with the Wlang compiler.");
  }
}

function compileExpression(expression: Expression): string {
  switch (expression.type) {
    case "FunctionCall": {
      const functionCall = expression as FunctionCall;
      return `${functionCall.identifier}(${
        functionCall.arguments.map(a => compileExpression(a)).join(", ")
      })`;
    }
    case "IntLiteral": case "FloatLiteral":
      return expression.value.toString();
    case "CstringLiteral":
      return `"${expression.value}"`;
    default:
      throw new Error("Internal error: Something is wrong with the Wlang compiler.");
  }
}

function convertToCType(type: ValueType): string {
  if (isPointer(type)) {
    return getPointerType(type as PointerType<ValueType> | NullablePointerType<ValueType>);
  } else if ((primitiveTypes as string[]).includes(type)) {
    return `const ${wlangToCDictionary[type as PrimitiveType]}`;
  } else if (isMut(type)) {
    const [_, t] = type.split(" ") as ["mut", PrimitiveType];
    return wlangToCDictionary[t];
  } else {
    throw new Error(`Type error: no such type as ${type} exists in Wlang.`);
  }
}

function isPointer(type: ValueType): boolean {
  return type.includes("ptr");
}

function isMut(type: ValueType): boolean {
  return type.startsWith("mut");
}

function getPointerType(type: PointerType<ValueType> | NullablePointerType<ValueType>): string {
  // Everything is nullable in C, so we can just strip out the question marks.
  const componentTypes =
    type.replace("?", "").split(" :- ") as [Pointer | Mut<Pointer>, ValueType, ...ValueType[]];
  const [pointer, typePointedTo] = componentTypes;
  if (componentTypes.length === 2) {
    if (isPointer(typePointedTo)) {
      throw new Error(
        "Type error: a pointer has to point to something. "
        + "Did you put `ptr :- ptr` in your code when you meant `ptr :- ptr :- T`?"
      );
    }
    let result = "";
    if (isMut(typePointedTo)) {
      const [_, t] = typePointedTo.split(" ") as ["mut", PrimitiveType];
      result += wlangToCDictionary[t];
    } else {
      result += `const ${wlangToCDictionary[typePointedTo as PrimitiveType]}`;
    }
    if (isMut(pointer)) {
      result += "*";
    } else {
      result += "*const "
    }
    return result;
  } else {
    if (!isPointer(componentTypes[1])) {
      throw new Error(
        "Type error: only a pointer can point to something."
        + `\`${componentTypes[1]} :- ${componentTypes[2]}\` is not a valid type.`
      );
    }
    const pointer = isMut(componentTypes[0]) ? "*" : "*const ";
    return getPointerType(componentTypes.slice(1).join(" :- ") as PointerType<ValueType>) + pointer;
  }
}

const wlangToCDictionary = {
  "inative": "int",
  "unative": "unsigned int",
  "i8": "char", // Note: may not be portable to Honeywell 6000 series mainframes.
  "u8": "unsigned char",
  "i16": "int16_t",
  "u16": "uint16_t",
  "i32": "int32_t",
  "u32": "uint32_t",
  "i64": "int64_t",
  "u64": "uint64_t",
  "float": "float",
  "double": "double",
  "size": "size_t",
  "void": "void",
  "ptr": "ERROR! The Wlang compiler did something wrong!"
};
